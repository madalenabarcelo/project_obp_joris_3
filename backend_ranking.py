# -*- coding: utf-8 -*-
"""project_obp_gary.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F94ZUqrcEug2al0BscdevVov2_w7fufW
"""

from sklearn.neighbors import NearestNeighbors

!git clone https://github.com/madalenabarcelo/project_obp_joris_3.git

# Commented out IPython magic to ensure Python compatibility.
# %cd project_obp_joris_3

import pandas as pd

file_path = 'many.csv'
data = pd.read_csv(file_path)

# Display the first few rows
print(data.head())

import requests
import pandas as pd
from itertools import combinations

def get_osrm_distance(coord1, coord2, profile='driving'):
    base_url = "http://router.project-osrm.org/route/v1"
    coords = f"{coord1[1]},{coord1[0]};{coord2[1]},{coord2[0]}"
    url = f"{base_url}/{profile}/{coords}"

    try:
        response = requests.get(url, params={"overview": "false"})
        response.raise_for_status()
        data = response.json()
        distance = data['routes'][0]['distance']  # Distance in meters
        return distance
    except requests.exceptions.RequestException as e:
        print(f"Error fetching OSRM data: {e}")
        return None

def calculate_distances_from_csv(file_path):
    locations = list(zip(data['lat'], data['lon']))
    location_names = data['name'].tolist()

    # Generate all pairs of locations
    pairs = list(combinations(enumerate(locations), 2))  # List of ((index1, coord1), (index2, coord2))

    # Calculate distances for each pair
    results = []
    for (idx1, coord1), (idx2, coord2) in pairs:
        distance = get_osrm_distance(coord1, coord2)
        results.append({
            'Location1': location_names[idx1],
            'Location2': location_names[idx2],
            'Distance (meters)': distance
        })

    # Convert results to a DataFrame
    return pd.DataFrame(results)

import folium
import pandas as pd
from folium import Map, CircleMarker
from itertools import cycle


# Assign a unique color to each company
colors = cycle(['red', 'blue', 'green', 'orange', 'purple'])  # Add more colors if needed
company_colors = {company: next(colors) for company in data['name'].unique()}

# Create a base map
m = folium.Map(location=[52.35, 4.85], zoom_start=12)

# Add points for each location
for _, row in data.iterrows():
    folium.CircleMarker(
        location=[row['lat'], row['lon']],
        radius=8,
        color=company_colors[row['name']],
        fill=True,
        fill_color=company_colors[row['name']],
        popup=f"Company: {row['name']}"
    ).add_to(m)

# Save and display the map
m.save("company_map.html")
m

!pip install joblib

# Bounding box


import requests
import pandas as pd
from itertools import combinations

# OSRM Distance Function
def get_osrm_distance(coord1, coord2, profile='driving'):
    """
    Calculate the distance between two coordinates using OSRM.
    """
    base_url = "http://router.project-osrm.org/route/v1"
    coords = f"{coord1[1]},{coord1[0]};{coord2[1]},{coord2[0]}"
    url = f"{base_url}/{profile}/{coords}"

    try:
        response = requests.get(url, params={"overview": "false"})
        response.raise_for_status()
        data = response.json()
        distance = data['routes'][0]['distance']  # Distance in meters
        return distance
    except requests.exceptions.RequestException as e:
        print(f"Error fetching OSRM data: {e}")
        return None

# Define central depot coordinates
DEPOT_LAT, DEPOT_LON = 52.333847, 4.865261  # Example coordinates
central_depot = (DEPOT_LAT, DEPOT_LON)

# Function to calculate bounding boxes
def calculate_bounding_boxes(data):
    bounding_boxes = {}
    for company in data['name'].unique():
        company_data = data[data['name'] == company]
        min_lat = company_data['lat'].min()
        max_lat = company_data['lat'].max()
        min_lon = company_data['lon'].min()
        max_lon = company_data['lon'].max()
        bounding_boxes[company] = {
            'min_lat': min_lat,
            'max_lat': max_lat,
            'min_lon': min_lon,
            'max_lon': max_lon
        }
    return bounding_boxes

# Function to calculate overlap area using OSRM distances
def calculate_overlap_area_osrm(box1, box2):
    """
    Use OSRM distances to refine bounding box overlap.
    """
    # Calculate the corners of the overlapping bounding box
    overlap_min_lat = max(box1['min_lat'], box2['min_lat'])
    overlap_max_lat = min(box1['max_lat'], box2['max_lat'])
    overlap_min_lon = max(box1['min_lon'], box2['min_lon'])
    overlap_max_lon = min(box1['max_lon'], box2['max_lon'])

    # Check if there is an actual overlap
    if overlap_min_lat < overlap_max_lat and overlap_min_lon < overlap_max_lon:
        # Calculate OSRM distances for the diagonal of the overlap
        top_left = (overlap_max_lat, overlap_min_lon)
        bottom_right = (overlap_min_lat, overlap_max_lon)
        overlap_distance = get_osrm_distance(top_left, bottom_right)

        # Approximate the area as a square using this distance
        return (overlap_distance ** 2) / 2 if overlap_distance else 0
    else:
        return 0  # No overlap

def rank_company_pairs_by_overlap(data):
    bounding_boxes = calculate_bounding_boxes(data)
    rankings = []

    for (company1, box1), (company2, box2) in combinations(bounding_boxes.items(), 2):
        # Calculate overlap area
        overlap_area = calculate_overlap_area_osrm(box1, box2)

        rankings.append((company1, company2, overlap_area))

    # Sort by overlap area in descending order (higher overlap is better)
    rankings.sort(key=lambda x: x[2], reverse=True)

    return pd.DataFrame(rankings, columns=['Company1', 'Company2', 'Overlap Area'])

ranked_pairs_by_overlap = rank_company_pairs_by_overlap(data)
print(ranked_pairs_by_overlap)

# Technique 1

# Bounding box
import pandas as pd
import geopandas as gpd
from shapely.geometry import Polygon
from itertools import combinations
from functools import lru_cache
import requests

# OSRM Distance Function
@lru_cache(maxsize=None)
def get_osrm_distance(coord1, coord2, profile='driving'):
    """
    Calculate the distance between two coordinates using OSRM.
    """
    base_url = "http://router.project-osrm.org/route/v1"
    coords = f"{coord1[1]},{coord1[0]};{coord2[1]},{coord2[0]}"
    url = f"{base_url}/{profile}/{coords}"

    try:
        response = requests.get(url, params={"overview": "false"})
        response.raise_for_status()
        data = response.json()
        distance = data['routes'][0]['distance']  # Distance in meters
        return distance
    except requests.exceptions.RequestException as e:
        print(f"Error fetching OSRM data: {e}")
        return None

# Define central depot coordinates
DEPOT_LAT, DEPOT_LON = 52.333847, 4.865261  # Example coordinates
central_depot = (DEPOT_LAT, DEPOT_LON)

# Function to calculate bounding boxes
def calculate_bounding_boxes(data):
    bounding_boxes = {}
    for company in data['name'].unique():
        company_data = data[data['name'] == company]
        min_lat = company_data['lat'].min()
        max_lat = company_data['lat'].max()
        min_lon = company_data['lon'].min()
        max_lon = company_data['lon'].max()
        bounding_boxes[company] = {
            'min_lat': min_lat,
            'max_lat': max_lat,
            'min_lon': min_lon,
            'max_lon': max_lon
        }
    return bounding_boxes

# Function to calculate overlap area using shapely
def calculate_overlap_area_osrm(box1, box2):
    """
    Use OSRM distances to refine bounding box overlap.
    """
    # Calculate the corners of the overlapping bounding box
    overlap_min_lat = max(box1['min_lat'], box2['min_lat'])
    overlap_max_lat = min(box1['max_lat'], box2['max_lat'])
    overlap_min_lon = max(box1['min_lon'], box2['min_lon'])
    overlap_max_lon = min(box1['max_lon'], box2['max_lon'])

    # Check if there is an actual overlap
    if overlap_min_lat < overlap_max_lat and overlap_min_lon < overlap_max_lon:
        # Calculate OSRM distances for the diagonal of the overlap
        top_left = (overlap_max_lat, overlap_min_lon)
        bottom_right = (overlap_min_lat, overlap_max_lon)
        overlap_distance = get_osrm_distance(top_left, bottom_right)

        # Approximate the area as a square using this distance
        return (overlap_distance ** 2) / 2 if overlap_distance else 0
    else:
        return 0  # No overlap

def rank_company_pairs_by_overlap(data):
    bounding_boxes = calculate_bounding_boxes(data)
    rankings = []

    for (company1, box1), (company2, box2) in combinations(bounding_boxes.items(), 2):
        # Calculate overlap area
        overlap_area = calculate_overlap_area_osrm(box1, box2)

        rankings.append((company1, company2, overlap_area))

    # Sort by overlap area in descending order (higher overlap is better)
    rankings.sort(key=lambda x: x[2], reverse=True)

    return pd.DataFrame(rankings, columns=['Company1', 'Company2', 'Overlap Area'])


ranked_pairs_by_overlap = rank_company_pairs_by_overlap(data)
print(ranked_pairs_by_overlap)

# Technique 2

import pandas as pd
import geopandas as gpd
from shapely.geometry import Polygon
from itertools import combinations
from functools import lru_cache
import requests
from joblib import Parallel, delayed
from numba import jit
import numpy as np

# OSRM Distance Function
@lru_cache(maxsize=None)
def get_osrm_distance(coord1, coord2, profile='driving'):
    """
    Calculate the distance between two coordinates using OSRM.
    """
    base_url = "http://router.project-osrm.org/route/v1"
    coords = f"{coord1[1]},{coord1[0]};{coord2[1]},{coord2[0]}"
    url = f"{base_url}/{profile}/{coords}"

    try:
        response = requests.get(url, params={"overview": "false"})
        response.raise_for_status()
        data = response.json()
        distance = data['routes'][0]['distance']  # Distance in meters
        return distance
    except requests.exceptions.RequestException as e:
        print(f"Error fetching OSRM data: {e}")
        return None

# Define central depot coordinates
DEPOT_LAT, DEPOT_LON = 52.333847, 4.865261  # Example coordinates
central_depot = (DEPOT_LAT, DEPOT_LON)

# Function to calculate bounding boxes
def calculate_bounding_boxes(data):
    bounding_boxes = {}
    for company in data['name'].unique():
        company_data = data[data['name'] == company]
        min_lat = company_data['lat'].min()
        max_lat = company_data['lat'].max()
        min_lon = company_data['lon'].min()
        max_lon = company_data['lon'].max()
        bounding_boxes[company] = {
            'min_lat': min_lat,
            'max_lat': max_lat,
            'min_lon': min_lon,
            'max_lon': max_lon
        }
    return bounding_boxes

# Function to calculate overlap area using shapely
def calculate_overlap_area(box1, box2):
    """
    Use shapely to calculate the overlap area between two bounding boxes.
    """
    polygon1 = Polygon([
        (box1['min_lon'], box1['min_lat']),
        (box1['max_lon'], box1['min_lat']),
        (box1['max_lon'], box1['max_lat']),
        (box1['min_lon'], box1['max_lat'])
    ])
    polygon2 = Polygon([
        (box2['min_lon'], box2['min_lat']),
        (box2['max_lon'], box2['min_lat']),
        (box2['max_lon'], box2['max_lat']),
        (box2['min_lon'], box2['max_lat'])
    ])
    if polygon1.intersects(polygon2):
        return polygon1.intersection(polygon2).area
    return 0

# Function to calculate overlap area using OSRM distances
def calculate_overlap_area_osrm(box1, box2):
    """
    Use OSRM distances to refine bounding box overlap.
    """
    # Calculate the corners of the overlapping bounding box
    overlap_min_lat = max(box1['min_lat'], box2['min_lat'])
    overlap_max_lat = min(box1['max_lat'], box2['max_lat'])
    overlap_min_lon = max(box1['min_lon'], box2['min_lon'])
    overlap_max_lon = min(box1['max_lon'], box2['max_lon'])

    # Check if there is an actual overlap
    if overlap_min_lat < overlap_max_lat and overlap_min_lon < overlap_max_lon:
        # Calculate OSRM distances for the diagonal of the overlap
        top_left = (overlap_max_lat, overlap_min_lon)
        bottom_right = (overlap_min_lat, overlap_max_lon)
        overlap_distance = get_osrm_distance(top_left, bottom_right)

        # Approximate the area as a square using this distance
        return (overlap_distance ** 2) / 2 if overlap_distance else 0
    else:
        return 0  # No overlap

# Function to evaluate a partnership
def rank_company_pairs_by_overlap(data):
    bounding_boxes = calculate_bounding_boxes(data)
    rankings = []

    for (company1, box1), (company2, box2) in combinations(bounding_boxes.items(), 2):
        # Calculate overlap area
        overlap_area = calculate_overlap_area_osrm(box1, box2)

        rankings.append((company1, company2, overlap_area))

    # Sort by overlap area in descending order (higher overlap is better)
    rankings.sort(key=lambda x: x[2], reverse=True)

    return pd.DataFrame(rankings, columns=['Company1', 'Company2', 'Overlap Area'])


ranked_pairs_by_overlap = rank_company_pairs_by_overlap(data)
print(ranked_pairs_by_overlap)

from IPython.display import IFrame
IFrame('company_map.html', width=700, height=500)

# Good clustering

from sklearn.cluster import DBSCAN
import folium
import pandas as pd

# Perform DBSCAN clustering
coords = data[['lat', 'lon']].values
dbscan = DBSCAN(eps=0.3, min_samples=2).fit(coords)
data['cluster'] = dbscan.labels_

# Visualize clusters on a map
def plot_dbscan_clusters(data, map_center):
    m = folium.Map(location=map_center, zoom_start=12)
    colors = ['blue', 'green', 'purple', 'orange', 'darkred']

    for _, row in data.iterrows():
        cluster = row['cluster']
        color = colors[cluster % len(colors)] if cluster != -1 else 'gray'  # Outliers in gray
        folium.Marker(
            location=(row['lat'], row['lon']),
            popup=f"Cluster {cluster}",
            icon=folium.Icon(color=color, icon='info-sign')
        ).add_to(m)

    return m

map_center = [52.37, 4.89]  # Approx. center of Amsterdam
map_result = plot_dbscan_clusters(data, map_center)

# Display the map
map_result

# rank and choose partnerships

import pandas as pd
from itertools import combinations
from sklearn.metrics.pairwise import haversine_distances
import numpy as np

# Function to compute average inter-cluster distance

def compute_cluster_distance(company1_data, company2_data):
    distances = []
    for _, row1 in company1_data.iterrows():
        for _, row2 in company2_data.iterrows():
            coord1 = np.radians([row1['lat'], row1['lon']])
            coord2 = np.radians([row2['lat'], row2['lon']])
            dist = haversine_distances([coord1, coord2])[0, 1] * 6371  # Radius of Earth in km
            distances.append(dist)
    return np.mean(distances)

# Generate all company pairs
companies = data['name'].unique()
partnerships = list(combinations(companies, 2))

# Evaluate each partnership
results = []
for company1, company2 in partnerships:
    company1_data = data[data['name'] == company1]
    company2_data = data[data['name'] == company2]

    # Filter to compatible clusters (same cluster ID)
    compatible_clusters = company1_data.merge(company2_data, on='cluster', suffixes=('_1', '_2'))

    if not compatible_clusters.empty:
        # Compute average distance between clusters
        avg_distance = compute_cluster_distance(company1_data, company2_data)
        score = len(compatible_clusters) / avg_distance  # Higher is better (more compatible points, closer)
    else:
        avg_distance = compute_cluster_distance(company1_data, company2_data)
        score = 0  # No compatible clusters

    results.append({
        'Partnership': f"{company1} & {company2}",
        'Average Distance (km)': avg_distance,
        'Score': score
    })

# Create a results DataFrame and rank by score
results_df = pd.DataFrame(results).sort_values(by='Score', ascending=False)
print(results_df)

# Ranked partnerships from the heuristic
ranked_partnerships = results_df.copy()

# Initialize selected partnerships and a set to track used companies
selected_partnerships = []
used_companies = set()

# Iteratively select the best partnerships
for _, row in ranked_partnerships.iterrows():
    partnership = row['Partnership']
    company1, company2 = partnership.split(' & ')

    # Check if either company is already paired
    if company1 not in used_companies and company2 not in used_companies:
        selected_partnerships.append(partnership)
        used_companies.update([company1, company2])  # Mark companies as used

# Display selected partnerships
print("Optimal Partnerships:")
for p in selected_partnerships:
    print(p)