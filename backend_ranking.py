# -*- coding: utf-8 -*-
"""project_obp_gary.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F94ZUqrcEug2al0BscdevVov2_w7fufW
"""

from sklearn.neighbors import NearestNeighbors

!git clone https://github.com/madalenabarcelo/project_obp_joris_3.git

# Commented out IPython magic to ensure Python compatibility.
# %cd project_obp_joris_3

import pandas as pd

#only change file name here
file_name='mini'

file_path = f"{file_name}.csv"
data = pd.read_csv(file_path)

"""# Bounding box"""

# Bounding box - Technique 2

import pandas as pd
import geopandas as gpd
from shapely.geometry import Polygon
from itertools import combinations
from functools import lru_cache
import requests
from joblib import Parallel, delayed
from numba import jit
import numpy as np

# OSRM Distance Function
@lru_cache(maxsize=None)
def get_osrm_distance(coord1, coord2, profile='driving'):
    """
    Calculate the distance between two coordinates using OSRM.
    """
    base_url = "http://router.project-osrm.org/route/v1"
    coords = f"{coord1[1]},{coord1[0]};{coord2[1]},{coord2[0]}"
    url = f"{base_url}/{profile}/{coords}"

    try:
        response = requests.get(url, params={"overview": "false"})
        response.raise_for_status()
        data = response.json()
        distance = data['routes'][0]['distance']  # Distance in meters
        return distance
    except requests.exceptions.RequestException as e:
        print(f"Error fetching OSRM data: {e}")
        return None

# Define central depot coordinates
DEPOT_LAT, DEPOT_LON = 52.333847, 4.865261  # Example coordinates
central_depot = (DEPOT_LAT, DEPOT_LON)

# Function to calculate bounding boxes
def calculate_bounding_boxes(data):
    bounding_boxes = {}
    for company in data['name'].unique():
        company_data = data[data['name'] == company]
        min_lat = company_data['lat'].min()
        max_lat = company_data['lat'].max()
        min_lon = company_data['lon'].min()
        max_lon = company_data['lon'].max()
        bounding_boxes[company] = {
            'min_lat': min_lat,
            'max_lat': max_lat,
            'min_lon': min_lon,
            'max_lon': max_lon
        }
    return bounding_boxes

# Function to calculate overlap area using shapely
def calculate_overlap_area(box1, box2):
    """
    Use shapely to calculate the overlap area between two bounding boxes.
    """
    polygon1 = Polygon([
        (box1['min_lon'], box1['min_lat']),
        (box1['max_lon'], box1['min_lat']),
        (box1['max_lon'], box1['max_lat']),
        (box1['min_lon'], box1['max_lat'])
    ])
    polygon2 = Polygon([
        (box2['min_lon'], box2['min_lat']),
        (box2['max_lon'], box2['min_lat']),
        (box2['max_lon'], box2['max_lat']),
        (box2['min_lon'], box2['max_lat'])
    ])
    if polygon1.intersects(polygon2):
        return polygon1.intersection(polygon2).area
    return 0

# Function to calculate overlap area using OSRM distances
def calculate_overlap_area_osrm(box1, box2):
    """
    Use OSRM distances to refine bounding box overlap.
    """
    # Calculate the corners of the overlapping bounding box
    overlap_min_lat = max(box1['min_lat'], box2['min_lat'])
    overlap_max_lat = min(box1['max_lat'], box2['max_lat'])
    overlap_min_lon = max(box1['min_lon'], box2['min_lon'])
    overlap_max_lon = min(box1['max_lon'], box2['max_lon'])

    # Check if there is an actual overlap
    if overlap_min_lat < overlap_max_lat and overlap_min_lon < overlap_max_lon:
        # Calculate OSRM distances for the diagonal of the overlap
        top_left = (overlap_max_lat, overlap_min_lon)
        bottom_right = (overlap_min_lat, overlap_max_lon)
        overlap_distance = get_osrm_distance(top_left, bottom_right)

        # Approximate the area as a square using this distance
        return (overlap_distance ** 2) / 2 if overlap_distance else 0
    else:
        return 0  # No overlap

# Function to evaluate a partnership
def rank_company_pairs_by_overlap(data):
    bounding_boxes = calculate_bounding_boxes(data)
    rankings = []

    for (company1, box1), (company2, box2) in combinations(bounding_boxes.items(), 2):
        # Calculate overlap area
        overlap_area = calculate_overlap_area_osrm(box1, box2)

        rankings.append((company1, company2, overlap_area))

    # Sort by overlap area in descending order (higher overlap is better)
    rankings.sort(key=lambda x: x[2], reverse=True)

    return pd.DataFrame(rankings, columns=['Company1', 'Company2', 'Overlap Area'])


ranked_pairs_by_overlap = rank_company_pairs_by_overlap(data)
print(ranked_pairs_by_overlap)

from IPython.display import IFrame
IFrame('company_map.html', width=700, height=500)

"""# Clustering"""

#create clusters

from sklearn.cluster import DBSCAN
import folium
import pandas as pd
from matplotlib import colormaps
import random

distance_matrices = {
    'mini': pd.read_csv('distance_matrix_mini1.csv', index_col=0).values,
    'medium': pd.read_csv('distance_matrix_medium.csv', index_col=0).values,
    'many': pd.read_csv('distance_matrix_many.csv', index_col=0).values,
    'manyLarge': pd.read_csv('distance_matrix_manyLarge.csv', index_col=0).values,
    'Amsterdam': pd.read_csv('distance_matrix_Amsterdam.csv', index_col=0).values
}


eps_values = {
    'mini': 50000,
    'medium': 20000,
    'many': 10000,
    'manyLarge': 5000,
    'Amsterdam': 1000
}


distance_matrix = distance_matrices[file_name]


def get_clusters_for_file(file_name):
    if file_name not in distance_matrices:
        raise ValueError(f"File name {file_name} not found in distance matrices.")


    # Get the corresponding eps value
    eps = eps_values.get(file_name)
    if eps is None:
        raise ValueError(f"No eps value defined for file {file_name}.")

    # Perform DBSCAN clustering
    dbscan = DBSCAN(eps=eps, min_samples=2, metric='precomputed')
    labels = dbscan.fit_predict(distance_matrix)

    return labels

# ranking partnerships

import numpy as np
from itertools import combinations
from geopy.distance import geodesic
import pandas as pd

# Function to rank partnerships using clusters
def rank_partnerships_using_clusters(data, labels, distance_matrix):
    # Add the cluster labels to the original data
    data['cluster'] = labels

    # Group data by cluster
    clustered_data = data.groupby('cluster')

    partnerships = []

    # For each cluster
    for cluster_id, group in clustered_data:
        if cluster_id == -1:
            continue  # Skip noise points

        # Extract unique companies in the cluster
        companies = group['name'].unique()

        # Calculate pairwise partnerships for companies in the cluster
        for company1, company2 in combinations(companies, 2):
            # Get indices for locations of each company
            indices1 = group[group['name'] == company1].index
            indices2 = group[group['name'] == company2].index

            # Compute distances based on the distance matrix
            distances = [
                distance_matrix[i, j] for i in indices1 for j in indices2
            ]

            # Calculate the heuristic (e.g., average distance)
            avg_distance = np.mean(distances)
            partnerships.append((cluster_id, company1, company2, avg_distance))

    # Sort partnerships by average distance (ascending)
    partnerships.sort(key=lambda x: x[3])
    return partnerships

"""# Frontend - calling of functions + map of clusters"""

# how to call function from the frontend
labels = get_clusters_for_file(file_name)

ranked_partnerships = rank_partnerships_using_clusters(data, labels, distance_matrix)

# Display results
for partnership in ranked_partnerships:
    print(f"Cluster {partnership[0]}: {partnership[1]} - {partnership[2]}, Avg Distance: {partnership[3]:.2f}")

import folium
from matplotlib import colormaps
import random

# Create a base map centered around the first point
base_map = folium.Map(location=[data['lat'].mean(), data['lon'].mean()], zoom_start=13)

unique_labels = set(labels)
color_map = {label: f'#{random.randint(0, 0xFFFFFF):06x}' for label in unique_labels}

# Add points to the map
for idx, (lat, lon, label) in enumerate(zip(data['lat'], data['lon'], labels)):
    color = color_map[label] if label != -1 else 'gray'
    popup_text = f"Index: {idx}, Cluster: {label}"
    folium.CircleMarker(
        location=(lat, lon),
        radius=5,
        color=color,
        fill=True,
        fill_opacity=0.7,
        popup=popup_text
    ).add_to(base_map)

# Save the map to an HTML file or display it
base_map.save('clusters_map.html')  # Save the map to a file
base_map  # Display the map in a Jupyter notebook
